#include <Romi32U4.h>

Romi32U4Motors motors;
Romi32U4Encoders encoders;

// PID constants
float Kp = 0.8, Ki = 0.2, Kd = 0.05;
float leftIntegral = 0, rightIntegral = 0;
float leftPrevError = 0, rightPrevError = 0;

// === REAL ROMI DIMENSIONS (Pololu Verified) ===
float wheelDiameter = 0.070;                 // 70 mm Romi wheel
float wheelCirc     = 3.14159 * wheelDiameter;
float ticksPerRev   = 1440.0;                // Romi encoder resolution
float wheelBase     = 0.142;                 // Romi wheel separation (14.2 cm) --> CHANGE IT TO CHASSIS LENGTH

// Set forward speed (m/s)
float v = 0.25;

// === CHANGE CURVE HERE ===
float R = 0.30; // meters (0.3 m radius curve)

// === STOP AT EXACT DISTANCE ===
float targetDistance = 4.14;  // meters
float totalDistance = 0;

unsigned long lastTime;

// Convert ticks → speed
float getWheelSpeed(int ticks, float dt)
{
  float revs = ticks / ticksPerRev;
  float distance = revs * wheelCirc;
  return distance / dt;  // m/s
}

// Convert ticks → distance (m)
float getWheelDistance(int ticks)
{
  float revs = ticks / ticksPerRev;
  return revs * wheelCirc;
}

float pidControl(float error, float &integral, float &prevError, float dt)
{
  integral += error * dt;
  float derivative = (error - prevError) / dt;
  prevError = error;

  return Kp * error + Ki * integral + Kd * derivative;
}

void setup()
{
  Serial.begin(115200);
  encoders.getCountsAndResetLeft();
  encoders.getCountsAndResetRight();
  lastTime = micros();
}

void loop()
{
  unsigned long now = micros();
  float dt = (now - lastTime) / 1e6;
  if (dt <= 0) return;
  lastTime = now;

  // --- Compute wheel target speeds for the curve ---
  float vL = v * (1 - (wheelBase / (2 * R)));
  float vR = v * (1 + (wheelBase / (2 * R)));

  // --- Encoder data ---
  int leftTicks  = encoders.getCountsAndResetLeft();
  int rightTicks = encoders.getCountsAndResetRight();

  float leftSpeed  = getWheelSpeed(leftTicks, dt);
  float rightSpeed = getWheelSpeed(rightTicks, dt);

  // Compute distances moved
  float leftDist  = getWheelDistance(leftTicks);
  float rightDist = getWheelDistance(rightTicks);
  float centerDist = (leftDist + rightDist) / 2.0;

  // Accumulate total distance
  totalDistance += centerDist;

  // Print to serial monitor
  Serial.print("Distance: ");
  Serial.println(totalDistance);

  // --- STOP AT 4.14 METERS ---
  if (totalDistance >= targetDistance)
  {
    motors.setSpeeds(0, 0);
    Serial.println("STOPPED — Reached 4.14 meters!");
    return;
  }

  // --- PID ---
  float leftError  = vL - leftSpeed;
  float rightError = vR - rightSpeed;

  float leftOutput  = pidControl(leftError,  leftIntegral,  leftPrevError,  dt);
  float rightOutput = pidControl(rightError, rightIntegral, rightPrevError, dt);

  int leftPWM  = constrain(leftOutput * 200,  -400, 400);
  int rightPWM = constrain(rightOutput * 200, -400, 400);

  motors.setSpeeds(leftPWM, rightPWM);
}
